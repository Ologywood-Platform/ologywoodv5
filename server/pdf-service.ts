import PDFDocument from 'pdfkit';
import { Readable } from 'stream';
import { v4 as uuidv4 } from 'uuid';

interface RiderTemplate {
  id: number;
  templateName: string;
  artistName: string;
  technicalRequirements?: {
    stageWidth?: string;
    stageDepth?: string;
    soundSystem?: string;
    lighting?: string;
    backline?: string;
    other?: string;
  };
  hospitalityRequirements?: {
    dressing?: string;
    catering?: string;
    parking?: string;
    accommodations?: string;
    other?: string;
  };
  financialRequirements?: {
    fee?: string;
    paymentTerms?: string;
    cancellationPolicy?: string;
    other?: string;
  };
}

interface SharedTemplate {
  id: string;
  templateId: number;
  artistId: number;
  shareToken: string;
  expiresAt: Date;
  createdAt: Date;
  accessCount: number;
}

// In-memory storage for shared templates (in production, use database)
const sharedTemplates: Map<string, SharedTemplate> = new Map();

export function generateRiderPDF(template: RiderTemplate): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({
      size: 'A4',
      margin: 50,
    });

    const chunks: Buffer[] = [];

    doc.on('data', (chunk: Buffer) => {
      chunks.push(chunk);
    });

    doc.on('end', () => {
      resolve(Buffer.concat(chunks));
    });

    doc.on('error', reject);

    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('RIDER AGREEMENT', { align: 'center' });
    doc.fontSize(12).font('Helvetica').text(`Artist: ${template.artistName}`, { align: 'center' });
    doc.fontSize(10).text(`Template: ${template.templateName}`, { align: 'center' });
    doc.moveDown();

    // Technical Requirements
    if (template.technicalRequirements && Object.keys(template.technicalRequirements).length > 0) {
      doc.fontSize(14).font('Helvetica-Bold').text('TECHNICAL REQUIREMENTS');
      doc.fontSize(11).font('Helvetica');

      const tech = template.technicalRequirements;
      if (tech.stageWidth) doc.text(`Stage Width: ${tech.stageWidth}`);
      if (tech.stageDepth) doc.text(`Stage Depth: ${tech.stageDepth}`);
      if (tech.soundSystem) doc.text(`Sound System: ${tech.soundSystem}`);
      if (tech.lighting) doc.text(`Lighting: ${tech.lighting}`);
      if (tech.backline) doc.text(`Backline: ${tech.backline}`);
      if (tech.other) doc.text(`Other: ${tech.other}`);

      doc.moveDown();
    }

    // Hospitality Requirements
    if (template.hospitalityRequirements && Object.keys(template.hospitalityRequirements).length > 0) {
      doc.fontSize(14).font('Helvetica-Bold').text('HOSPITALITY REQUIREMENTS');
      doc.fontSize(11).font('Helvetica');

      const hosp = template.hospitalityRequirements;
      if (hosp.dressing) doc.text(`Dressing Room: ${hosp.dressing}`);
      if (hosp.catering) doc.text(`Catering: ${hosp.catering}`);
      if (hosp.parking) doc.text(`Parking: ${hosp.parking}`);
      if (hosp.accommodations) doc.text(`Accommodations: ${hosp.accommodations}`);
      if (hosp.other) doc.text(`Other: ${hosp.other}`);

      doc.moveDown();
    }

    // Financial Requirements
    if (template.financialRequirements && Object.keys(template.financialRequirements).length > 0) {
      doc.fontSize(14).font('Helvetica-Bold').text('FINANCIAL REQUIREMENTS');
      doc.fontSize(11).font('Helvetica');

      const fin = template.financialRequirements;
      if (fin.fee) doc.text(`Fee: ${fin.fee}`);
      if (fin.paymentTerms) doc.text(`Payment Terms: ${fin.paymentTerms}`);
      if (fin.cancellationPolicy) doc.text(`Cancellation Policy: ${fin.cancellationPolicy}`);
      if (fin.other) doc.text(`Other: ${fin.other}`);

      doc.moveDown();
    }

    // Footer
    doc.fontSize(9).text('Generated by Ologywood', { align: 'center' });
    doc.text(`Date: ${new Date().toLocaleDateString()}`, { align: 'center' });

    doc.end();
  });
}

export function createSharedTemplate(
  templateId: number,
  artistId: number,
  expirationDays: number = 30
): SharedTemplate {
  const shareToken = uuidv4();
  const id = uuidv4();

  const shared: SharedTemplate = {
    id,
    templateId,
    artistId,
    shareToken,
    expiresAt: new Date(Date.now() + expirationDays * 24 * 60 * 60 * 1000),
    createdAt: new Date(),
    accessCount: 0,
  };

  sharedTemplates.set(shareToken, shared);
  return shared;
}

export function getSharedTemplate(shareToken: string): SharedTemplate | null {
  const template = sharedTemplates.get(shareToken);

  if (!template) return null;

  // Check if expired
  if (new Date() > template.expiresAt) {
    sharedTemplates.delete(shareToken);
    return null;
  }

  // Increment access count
  template.accessCount++;
  return template;
}

export function revokeSharedTemplate(shareToken: string): boolean {
  return sharedTemplates.delete(shareToken);
}

export function getSharedTemplatesByArtist(artistId: number): SharedTemplate[] {
  const templates: SharedTemplate[] = [];

  sharedTemplates.forEach((template, token) => {
    if (template.artistId === artistId && new Date() <= template.expiresAt) {
      templates.push(template);
    }
  });

  return templates;
}

export function generateShareLink(shareToken: string): string {
  const baseUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
  return `${baseUrl}/shared-rider/${shareToken}`;
}

export function formatExpirationDate(date: Date): string {
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}
